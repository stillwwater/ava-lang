// Signature file for parser generated by fsyacc
module Parser
type token = 
  | Empty
  | EOF
  | EOL
  | KW_COUNT
  | DR_UNCHECKED
  | DR_EXTERN
  | KW_EXPORT
  | KW_CONTINUE
  | KW_BREAK
  | KW_RETURN
  | KW_ELSIF
  | KW_ELSE
  | KW_OF
  | KW_END
  | KW_DO
  | KW_WHILE
  | KW_THEN
  | KW_IF
  | RARROW
  | RBRACKET
  | LBRACKET
  | RPAREN
  | LPAREN
  | AMP
  | KW_NOT
  | KW_AND
  | KW_OR
  | GREATER
  | GREATER_EQUALS
  | LESS
  | LESS_EQUALS
  | KW_IS
  | LESS_GREATER
  | DOUBLE_EQUALS
  | PERCENT
  | ASTERISK
  | FSLASH
  | PLUS
  | MINUS
  | COLON_EQUALS
  | DOUBLE_COLON
  | SINGLE_EQUALS
  | DOUBLE_DOLLAR
  | DOLLAR
  | HASH
  | DOT
  | COLON
  | SEMI_COLON
  | COMMA
  | KW_TEXT
  | KW_STRING
  | KW_CHAR
  | KW_BYTE
  | KW_INT
  | KW_VOID
  | KW_FLOAT
  | IDENT of (string)
  | BYTE_LITERAL of (byte)
  | STRING_LITERAL of (string)
  | FLOAT_LITERAL of (float32)
  | INT_LITERAL of (int)
type tokenId = 
    | TOKEN_Empty
    | TOKEN_EOF
    | TOKEN_EOL
    | TOKEN_KW_COUNT
    | TOKEN_DR_UNCHECKED
    | TOKEN_DR_EXTERN
    | TOKEN_KW_EXPORT
    | TOKEN_KW_CONTINUE
    | TOKEN_KW_BREAK
    | TOKEN_KW_RETURN
    | TOKEN_KW_ELSIF
    | TOKEN_KW_ELSE
    | TOKEN_KW_OF
    | TOKEN_KW_END
    | TOKEN_KW_DO
    | TOKEN_KW_WHILE
    | TOKEN_KW_THEN
    | TOKEN_KW_IF
    | TOKEN_RARROW
    | TOKEN_RBRACKET
    | TOKEN_LBRACKET
    | TOKEN_RPAREN
    | TOKEN_LPAREN
    | TOKEN_AMP
    | TOKEN_KW_NOT
    | TOKEN_KW_AND
    | TOKEN_KW_OR
    | TOKEN_GREATER
    | TOKEN_GREATER_EQUALS
    | TOKEN_LESS
    | TOKEN_LESS_EQUALS
    | TOKEN_KW_IS
    | TOKEN_LESS_GREATER
    | TOKEN_DOUBLE_EQUALS
    | TOKEN_PERCENT
    | TOKEN_ASTERISK
    | TOKEN_FSLASH
    | TOKEN_PLUS
    | TOKEN_MINUS
    | TOKEN_COLON_EQUALS
    | TOKEN_DOUBLE_COLON
    | TOKEN_SINGLE_EQUALS
    | TOKEN_DOUBLE_DOLLAR
    | TOKEN_DOLLAR
    | TOKEN_HASH
    | TOKEN_DOT
    | TOKEN_COLON
    | TOKEN_SEMI_COLON
    | TOKEN_COMMA
    | TOKEN_KW_TEXT
    | TOKEN_KW_STRING
    | TOKEN_KW_CHAR
    | TOKEN_KW_BYTE
    | TOKEN_KW_INT
    | TOKEN_KW_VOID
    | TOKEN_KW_FLOAT
    | TOKEN_IDENT
    | TOKEN_BYTE_LITERAL
    | TOKEN_STRING_LITERAL
    | TOKEN_FLOAT_LITERAL
    | TOKEN_INT_LITERAL
    | TOKEN_end_of_input
    | TOKEN_error
type nonTerminalId = 
    | NONTERM__startstart
    | NONTERM_start
    | NONTERM_program
    | NONTERM_decl_list
    | NONTERM_decl
    | NONTERM_type_spec
    | NONTERM_array_type_spec
    | NONTERM_fixed_decl
    | NONTERM_variable_decl
    | NONTERM_fixed_scalar_decl
    | NONTERM_fixed_array_decl
    | NONTERM_scalar_decl
    | NONTERM_array_decl
    | NONTERM_procedure_decl
    | NONTERM_parameters
    | NONTERM_parameter_list
    | NONTERM_parameter
    | NONTERM_stmt_list
    | NONTERM_stmt
    | NONTERM_sexpr
    | NONTERM_while_stmt
    | NONTERM_if_stmt
    | NONTERM_cond_clause_s
    | NONTERM_cond_clause
    | NONTERM_cond_part
    | NONTERM_condition
    | NONTERM_else_opt
    | NONTERM_compound_stmt
    | NONTERM_break_stmt
    | NONTERM_continue_stmt
    | NONTERM_return_stmt
    | NONTERM_expr_list
    | NONTERM_aggregate
    | NONTERM_expr
    | NONTERM_logical
    | NONTERM_relation
    | NONTERM_relational
    | NONTERM_equation
    | NONTERM_unary
    | NONTERM_combinatory
    | NONTERM_term
    | NONTERM_sequential
    | NONTERM_factor
    | NONTERM_primary
    | NONTERM_qualified
    | NONTERM_paren_primary
    | NONTERM_arguments
    | NONTERM_literal
/// This function maps tokens to integer indexes
val tagOfToken: token -> int

/// This function maps integer indexes to symbolic token ids
val tokenTagToTokenId: int -> tokenId

/// This function maps production indexes returned in syntax errors to strings representing the non terminal that would be produced by that production
val prodIdxToNonTerminal: int -> nonTerminalId

/// This function gets the name of a token as a string
val token_to_string: token -> string
val start : (Microsoft.FSharp.Text.Lexing.LexBuffer<'cty> -> token) -> Microsoft.FSharp.Text.Lexing.LexBuffer<'cty> -> (Program) 
